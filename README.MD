# Checklist

- [x] Clean Architecture
- [x] Valida√ß√£o com Zod
- [x] Documenta√ß√£o Swagger autom√°tica
- [x] Criptografia simulada (fakeEncrypt/fakeDecrypt)
- [x] Testes unit√°rios para cada rota/caso de uso

# Estrutura de Pastas

```bash
src/
‚îÇ
‚îú‚îÄ‚îÄ üìÇ application      # Casos de uso (UseCases) e regras da aplica√ß√£o
‚îú‚îÄ‚îÄ üìÇ common           # Utilit√°rios, helpers, classes de erro etc.
‚îú‚îÄ‚îÄ üìÇ config           # Configura√ß√µes globais
‚îú‚îÄ‚îÄ üìÇ domain           # Entidades e regras de dom√≠nio
‚îú‚îÄ‚îÄ üìÇ infra            # Implementa√ß√µes externas (DB, APIs, etc.)
‚îú‚îÄ‚îÄ üìÇ presentation     # Camada HTTP (controllers, rotas, valida√ß√µes)
‚îú‚îÄ‚îÄ üìÇ scripts          # Scripts auxiliares
‚îú‚îÄ‚îÄ üìÇ test             # Testes unit√°rios
‚îú‚îÄ‚îÄ üìÇ types            # Tipagens globais
‚îî‚îÄ‚îÄ üìÑ main.ts          # Ponto de entrada da aplica√ß√£o

```

# Como inicializar o Projeto

1. **Pr√©-requisitos**
   - Node.js 18+
   - Yarn ou npm
   - Docker

2. **Subindo o banco de dados**

   ```bash
   docker-compose up -d
   ```

   - Aguarde o MySQL inicializar.
   - As tabelas do banco s√£o criadas ao inicializar a aplica√ß√£o no passo (5), mas tamb√©m √© poss√≠vel executar o script a parte caso deseje com:
     `npx tsx src/scripts/db/createTables.script.ts createtables`

3. **Instala√ß√£o**

   ```bash
   yarn install
   # ou
   npm install
   ```

4. **Configura√ß√£o**
   - Crie o arquivo `.env` e preencha as vari√°veis necess√°rias:
     ```
     ENCRYPTION_KEY=chave-secreta
     DB_HOST=localhost
     DB_PORT=3306
     DB_USER=user
     DB_PASSWORD=password
     DB_DATABASE=payments
     ```

5. **Rodando o servidor**

   ```bash
   yarn start
   # ou
   npm start
   ```

6. **Acessando a documenta√ß√£o**
   - Acesse `http://localhost:3000/docs` para visualizar o Swagger.

7. **Rodando os testes**
   ```bash
   yarn test
   # ou
   npm test
   ```

# Banco de Dados

No banco de dados, optei por criar duas tabelas (**payments** e **refunds**) por uma quest√£o de boa pr√°tica de normaliza√ß√£o. Mesmo que o cen√°rio n√£o seja real, separar os dados permite armazenar informa√ß√µes importantes, como o valor e a data de cada reembolso realizado, facilitando consultas e mantendo o hist√≥rico organizado.

## Tabelas

### payments

Armazena os pagamentos registrados.

| Coluna      | Tipo                                    | Descri√ß√£o                                                            |
| ----------- | --------------------------------------- | -------------------------------------------------------------------- |
| id          | INT AUTO_INCREMENT PRIMARY KEY          | Identificador do pagamento.                                          |
| type        | ENUM('pix', 'credit_card')              | Tipo de pagamento.                                                   |
| amount      | INT NOT NULL                            | Valor do pagamento multiplicado por 100. Exemplo: 1000.23 -> 100023. |
| card_data   | TEXT                                    | Dados do cart√£o (criptografados).                                    |
| type        | ENUM('PENDING', 'APPROVED', 'DECLINED') | status do pagamento.                                                 |
| buyer_name  | VARCHAR(255)                            | Nome do comprador.                                                   |
| buyer_email | VARCHAR(255)                            | Email do pagador.                                                    |
| created_at  | TIMESTAMP                               | Data/hora de cria√ß√£o.                                                |
| updated_at  | TIMESTAMP                               | Data/hora da √∫ltima atualiza√ß√£o.                                     |

---

### refunds

Armazena os estornos/refunds realizados.

| Coluna      | Tipo                           | Descri√ß√£o                                                         |
| ----------- | ------------------------------ | ----------------------------------------------------------------- |
| id          | INT AUTO_INCREMENT PRIMARY KEY | Identificador do refund.                                          |
| payment_id  | INT NOT NULL                   | ID do pagamento associado.                                        |
| amount      | INT NOT NULL                   | Valor do refund multiplicado por 100. Exemplo: 1000.23 -> 100023. |
| refund_type | ENUM('total', 'partial')       | Tipo do estorno (total ou parcial).                               |
| created_at  | TIMESTAMP                      | Data/hora de cria√ß√£o.                                             |
| updated_at  | TIMESTAMP                      | Data/hora da √∫ltima atualiza√ß√£o.                                  |

- Chave estrangeira: `payment_id` referencia `payments(id)`.

---

### Observa√ß√µes

- Valores monet√°rios s√£o armazenados como **inteiros multiplicados por 100** para evitar problemas de arredondamento.

# Observa√ß√£o na rota de criar pagamento (CRIPTOGRAFIA)

## Rota: `POST /payments`

### Descri√ß√£o

Esta rota cria um pagamento. O payload da requisi√ß√£o deve seguir o schema abaixo.

### Payload esperado

```json
{
  "method": "pix" | "credit_card",
  "amount": number (positivo),
  "card": { "encryptedData": string } (opcional, obrigat√≥rio para credit_card),
  "buyer": {
    "name": string,
    "email": string (formato v√°lido)
  }
}
```

### Campo `card.encryptedData`

Para encriptar no lado cliente eu tinha duas alternativas em mente, criar uma fun√ß√£o para encriptar os dados com uma **chave p√∫blica** e manter uma **chave privada** no servidor ou o base64, optei pelo o base64 pois acredito que facilitaria no teste

Cont√©m os dados do cart√£o em formato **Base64**

Para converter JSON para Base64 use esta ferramenta:
https://codebeautify.org/json-to-base64-converter

Exemplo JSON esperado em base64:

```json
{
  "number": "4111111111111111",
  "cvv": "456",
  "expirationDate": "03/27"
}
```

Em `infra/crypto` possui os m√©todos de encriptar e desencriptar fake, em um cen√°rio real optaria por **chave p√∫blica/privada**

